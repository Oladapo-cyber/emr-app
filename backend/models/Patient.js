import mongoose from "mongoose";
import Counter from "./Counter.js";

// Define the Patient schema structure
const patientSchema = new mongoose.Schema(
  {
    // Basic Information
    firstName: {
      type: String,
      required: [true, "First name is required"],
      trim: true, 
      maxlength: [50, "First name cannot exceed 50 characters"], 
    },
    lastName: {
      type: String,
      required: [true, "Last name is required"],
      trim: true,
      maxlength: [50, "Last name cannot exceed 50 characters"],
    },
    dateOfBirth: {
      type: Date,
      required: [true, "Date of birth is required"], 
    },
    gender: {
      type: String,
      enum: ["male", "female", "other"],
      required: [true, "Gender is required"],
    },

    // Contact Information
    email: {
      type: String,
      lowercase: true, 
      trim: true,
      // Regex validation for email format
      match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, "Invalid email"],
    },
    phone: {
      type: String,
      required: [true, "Phone number is required"],
      // Regex allows: +234, 123-456-7890, (123) 456-7890, etc.
      match: [/^\+?[\d\s\-\(\)]+$/, "Invalid phone number"],
    },
    address: {
      // Nested object for structured address
      street: String,
      city: String,
      state: String,
      country: { type: String, default: "Nigeria" },
    },

    // Patient ID (auto-generated by pre-save middleware)
    patientId: {
      type: String,
      unique: true, 
      // Note: Not marked as required because it's generated in pre-save hook
    },

    // Medical Information
    bloodType: {
      type: String,
      // Standard blood types - optional field
      enum: ["A+", "A-", "B+", "B-", "AB+", "AB-", "O+", "O-"],
    },
    allergies: [
      // Array of allergy objects
      {
        type: String,
        trim: true,
      }
    ],

    // Insurance Information
    insurance: {
      provider: String,
      policyNumber: String,
      groupNumber: String,
      policyHolder: String,
      effectiveDate: Date,
      expirationDate: Date,
    },

    // Emergency Contact
    emergencyContact: {
      // Single nested object for emergency contact
      name: {
        type: String,
        trim: true,
      },
      phone: {
        type: String,
        trim: true,
        match: [/^\+?[\d\s\-\(\)]+$/, "Invalid phone number"],
      },
      relationship: {
        type: String,
        trim: true,
      },
    },

    // Healthcare Provider
    primaryDoctor: {
      type: mongoose.Schema.ObjectId, // Reference to User collection
      ref: "User", // Establishes relationship with User model (doctor)
      // Optional field - patient may not have assigned doctor yet
    },

    // Status
    isActive: {
      type: Boolean,
      default: true, // New patients are active by default
      // Used for soft deletion - instead of deleting, set to false
    },

    // Audit Trail
    createdBy: {
      type: mongoose.Schema.ObjectId,
      ref: "User", // Reference to the user who created this patient record
      required: true, // Must track who created the record for audit purposes
    },
    updatedBy: {
      type: mongoose.Schema.ObjectId,
      ref: "User",
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// ==================== INDEXES ====================

// Single field indexes
patientSchema.index({ email: 1 });
// patientId index already defined with unique: true in schema
patientSchema.index({ phone: 1 });
patientSchema.index({ isActive: 1 });

// Compound indexes for common queries
patientSchema.index({ firstName: 1, lastName: 1 });
patientSchema.index({ isActive: 1, createdAt: -1 });
patientSchema.index({ primaryDoctor: 1, isActive: 1 });

//Virtual Fields- Computed properties that don't exist in the database

// Virtual for full name  
patientSchema.virtual("fullName").get(function () {
  return `${this.firstName} ${this.lastName}`;
  // Usage: patient.fullName returns "John Doe"
});

// Virtual for age calculation - computes age from dateOfBirth
patientSchema.virtual("age").get(function () {
  if (!this.dateOfBirth) return null; // Return null if no birth date

  const today = new Date();
  const birth = new Date(this.dateOfBirth);
  let age = today.getFullYear() - birth.getFullYear(); // Basic year difference
  const monthDiff = today.getMonth() - birth.getMonth();

  // Adjust age if birthday hasn't occurred this year yet
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--;
  }
  return age;
  // Usage: patient.age returns 25 (calculated automatically)
});

// Pre-save middleware: Generate unique Patient ID using atomic counter to prevent race conditions, yearly reset 
patientSchema.pre("save", async function (next) {
  try {
    // Only generate ID for new patients without an ID
    if (this.isNew && !this.patientId) {
      const year = new Date().getFullYear();
      const counterName = `patient_${year}`;

      // Get next sequence number atomically
      const sequence = await Counter.getNextSequence(counterName);

      // Generate patient ID with format: PAT{YEAR}{SEQUENCE}
      // Pad sequence to 4 digits: 1 → 0001, 42 → 0042, 999 → 0999
      const paddedSequence = String(sequence).padStart(4, "0");
      this.patientId = `PAT${year}${paddedSequence}`;

      console.log(`✅ Generated Patient ID: ${this.patientId}`);
    }

    next();
  } catch (error) {
    console.error("❌ Error generating patient ID:", error);
    next(error);
  }
});

// Pre-update middleware to track who updated
patientSchema.pre("findOneAndUpdate", function (next) {
  this.set({ updatedAt: new Date() });
  next();
});

// ==================== STATIC METHODS ====================

/**
 * Find patient by patientId
 * @param {string} patientId - Patient ID (e.g., "PAT20240001")
 * @returns {Promise<Object>} Patient document
 */
patientSchema.statics.findByPatientId = function (patientId) {
  return this.findOne({ patientId, isActive: true })
    .populate("primaryDoctor", "firstName lastName employeeId")
    .populate("createdBy", "firstName lastName");
};

// Search patients by multiple criteria
patientSchema.statics.searchPatients = function (searchTerm) {
  const regex = new RegExp(searchTerm, "i"); // Case-insensitive search
  
  return this.find({
    isActive: true,[]
    $or: [
      { firstName: regex },
      { lastName: regex },
      { patientId: regex },
      { email: regex },
      { phone: regex },
    ],
  })
    .populate("primaryDoctor", "firstName lastName")
    .sort({ lastName: 1, firstName: 1 })
    .limit(50);
};

// ==================== INSTANCE METHODS ====================

/**
 * Check if patient has active insurance
 * @returns {boolean} True if patient has valid insurance
 */
patientSchema.methods.hasActiveInsurance = function () {
  if (!this.insurance?.provider) return false;
  if (!this.insurance?.expirationDate) return false;

  const today = new Date();
  const expirationDate = new Date(this.insurance.expirationDate);

  return expirationDate > today;
};

// Soft delete patient
patientSchema.methods.softDelete = function (userId) {
  this.isActive = false;
  this.updatedBy = userId;
  return this.save();
};

const Patient = mongoose.model("Patient", patientSchema);
export default Patient;